<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wave Rogue Shooter</title>
<style>
  :root{--hud-bg:rgba(0,0,0,0.45);--card:#0f1720}
  html,body{height:100%;margin:0;background:#0b0b0b;color:#eee;font-family:Inter, Arial, sans-serif;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;background:#000}
  #hud{position:absolute;top:8px;left:50%;transform:translateX(-50%);display:flex;gap:18px;padding:8px 12px;border-radius:10px;background:var(--hud-bg);font-weight:600}
  #hud span b{color:#aee1ff}
  #overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(10,14,20,0.88);padding:18px;border-radius:12px;min-width:720px;max-width:95%;box-shadow:0 8px 40px rgba(0,0,0,0.6)}
  .title{font-size:20px;margin-bottom:10px;text-align:center}
  .choices{display:flex;gap:12px;justify-content:center;flex-wrap:wrap}
  .card{background:linear-gradient(180deg,#071019,#0b1220);padding:12px;border-radius:10px;flex:1 1 220px;min-width:220px;cursor:pointer;border:1px solid rgba(255,255,255,0.03)}
  .card:hover{transform:translateY(-6px);box-shadow:0 12px 30px rgba(0,0,0,0.6)}
  .card h3{margin:0 0 6px 0;font-size:16px}
  .card p{margin:0;font-size:13px;opacity:0.9}
  .small{font-size:12px;opacity:0.8;margin-top:8px}
  #powerList{position:absolute;right:12px;top:60px;max-width:260px;padding:10px;background:var(--hud-bg);border-radius:8px}
  #powerList h4{margin:0 0 6px 0;font-size:13px}
  .powerItem{font-size:13px;margin:4px 0;padding:6px;background:rgba(255,255,255,0.02);border-radius:6px}
  .muted{opacity:0.8;font-size:12px}
  .footer{margin-top:10px;text-align:center;font-size:13px;color:#cfe}
  button.small{background:#0e6dfd;border:0;padding:8px 10px;border-radius:8px;color:white;cursor:pointer}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">
  <span>Wave: <b id="wave">1</b></span>
  <span>Enemies: <b id="enemies">0</b></span>
  <span>HP: <b id="hp">100</b></span>
  <span>Score: <b id="score">0</b></span>
  <span class="muted"> â€” Pick powerups between waves (click)</span>
</div>

<div id="overlay" hidden>
  <div class="panel" id="pickPanel">
    <div class="title" id="pickTitle">Choose a powerup</div>
    <div class="choices" id="choices"></div>
    <div class="footer">Pick one. Effects stack. Press R to restart anytime.</div>
  </div>
</div>

<div id="powerList">
  <h4>Active Upgrades</h4>
  <div id="activeList"></div>
</div>

<script>
/* --------- Core setup & helpers --------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = innerWidth, H = innerHeight;
canvas.width = W; canvas.height = H;

const elWave = document.getElementById('wave');
const elEnemies = document.getElementById('enemies');
const elHp = document.getElementById('hp');
const elScore = document.getElementById('score');
const overlay = document.getElementById('overlay');
const choicesNode = document.getElementById('choices');
const activeListNode = document.getElementById('activeList');

let keys = {}, mouse = {x:W/2,y:H/2,down:false};
let bullets = [], enemies = [];
let wave = 1, betweenWave = 0, score = 0;
let lastShot = 0, gameOver = false;
const player = {x:W/2,y:H/2,r:16,speed:240,hp:100,maxHp:100,shield:0};
const defaultShotDelay = 150;
let shotDelay = defaultShotDelay; // ms
let bulletSpeed = 700;
let bulletRadius = 4;
let bulletDamage = 1;
let pierce = 0; // number of extra enemies bullet can pass through
let shotgun = 0; // extra projectiles (n means fire n bullets in spread inclusive)
let explosive = 0; // explosive level
let ricochet = 0; // ricochet bounces
let homing = 0; // homing strength (0 none, >0 slight)
let critChance = 0; // 0-1
let critMult = 1.5;
let healOnKill = 0; // hp per kill
let lifesteal = 0; // percent of damage returned as hp
let moveSpeedBonus = 0;
let maxHpBonus = 0;
let armor = 0; // damage reduction percent (0-0.5)
let regenPerSecond = 0;
let slowAura = 0; // slows enemies within radius
let stunChance = 0;
let fireRateScalingLowHP = 0; // increases fire rate when low hp
let spawnReduce = 0; // reduces enemy spawn count per wave (integer)
let extraScore = 0; // multiplier or flat? implement flat
let shotgunSpread = 0.25; // radians between pellets (base)
let bulletPierceExplosive = false;

const powerCounts = {}; // track stacks
const ALL_POWERS = []; // filled later

function rand(min,max){ return Math.random()*(max-min)+min }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)) }
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y) }

/* --------- Powerup definitions (28 total) --------- */
function addPower(id,name,desc,applyFn){
  ALL_POWERS.push({id,name,desc,applyFn});
  powerCounts[id] = 0;
}

// 1
addPower('dmg_up','Damage Up','Increase base bullet damage by +1 (stacks)',()=>{
  bulletDamage += 1;
});
// 2
addPower('firerate_up','Attack Speed','Reduce shot cooldown by 10% (multiplicative, stacks)',()=>{
  shotDelay *= 0.9;
});
// 3
addPower('hp_max','Max HP +','Increase maximum HP by +10',()=>{
  maxHpBonus += 10; player.maxHp = player.maxHp + 10; player.hp += 10;
});
// 4
addPower('move_speed','Agility','Increase movement speed by +10%',()=>{
  moveSpeedBonus += 0.10; player.speed *= 1.10;
});
// 5
addPower('bullet_size','Heavy Rounds','Bullets are larger (+1 px radius)',()=>{
  bulletRadius += 1;
});
// 6
addPower('bullet_speed','Velocity','Bullets travel 10% faster',()=>{
  bulletSpeed *= 1.10;
});
// 7
addPower('pierce','Piercing Rounds','Bullets pierce +1 extra enemy',()=>{
  pierce += 1;
});
// 8
addPower('shotgun','Shotgun','Fire 1 extra projectile in a spread (stacks)',()=>{
  shotgun += 1;
});
// 9
addPower('explosive','Explosive','Bullets explode on hit dealing area damage',()=>{
  explosive += 1;
  bulletPierceExplosive = true;
});
// 10
addPower('ricochet','Ricochet','Bullets can bounce off walls once',()=>{
  ricochet += 1;
});
// 11
addPower('homing','Homing','Bullets slightly home into nearest enemy',()=>{
  homing += 1;
});
// 12
addPower('crit','Critical Hit','Small chance for double damage (adds 6%)',()=>{
  critChance += 0.06;
  critMult = 1.5 + (powerCounts['crit']>0?0:0); // keep base at 1.5
});
// 13
addPower('crit_mult','Killer Instinct','Increase critical damage multiplier (+0.2)',()=>{
  critMult += 0.2;
});
// 14
addPower('heal_kill','Vampire','Heal +4 HP on enemy kill',()=>{
  healOnKill += 4;
});
// 15
addPower('lifesteal','Life Leech','Return small percent of damage as HP (2%)',()=>{
  lifesteal += 0.02;
});
// 16
addPower('armor','Armor','Reduce incoming damage by 6% (multiplicative)',()=>{
  armor += 0.06;
});
// 17
addPower('regen','Regeneration','Regenerate +1 HP/sec',()=>{
  regenPerSecond += 1;
});
// 18
addPower('slow_aura','Frost Aura','Slow enemies near you slightly',()=>{
  slowAura += 0.08; // percent slow stacked
});
// 19
addPower('stun','Stun Chance','Small chance to stun enemies on hit (5%)',()=>{
  stunChance += 0.05;
});
// 20
addPower('overcharge','Overcharge','Fire rate increases by 25% when below 35% HP',()=>{
  fireRateScalingLowHP += 0.25;
});
// 21
addPower('spawn_reduce','Field Control','Reduce number of enemies per wave by 1 (stacks)',()=>{
  spawnReduce += 1;
});
// 22
addPower('score_boost','Greed','Gain +5 extra score per kill',()=>{
  extraScore += 5;
});
// 23
addPower('shield','Shield','Grants a small temporary shield that absorbs damage on pickup (permanent small shield +8)',()=>{
  player.shield += 8;
});
// 24
addPower('double_shot','Double Tap','Chance to fire double shot (stacked chance +8%)',()=>{
  // implement as a proc chance to spawn extra bullet
  critChance += 0; // no-op visually, handled in shooting code with powerCounts
});
// 25
addPower('bounce_up','Crowd Push','Enemies slightly push each other more (soft crowd movement)',()=>{
  // handled by collision strength adjustments via stack counts - no direct stat
});
// 26
addPower('pierce_explode','Shrapnel','Explosive bullets also pierce nearby enemies',()=>{
  bulletPierceExplosive = true;
  pierce += 0; // further logic handled on explosion
});
// 27
addPower('megashell','Mega Shell','Increase explosive radius and damage',()=>{
  explosive += 1; // stacks more explosive power
});
// 28
addPower('ricochet_plus','Ricochet Mastery','Additional ricochet bounces',()=>{
  ricochet += 1;
});

// For each time a power is picked we call the apply function and increment count
function grantPower(power){
  powerCounts[power.id] = (powerCounts[power.id] || 0) + 1;
  if(power.applyFn !== undefined){
    power.applyFn();
  } else {
    // If the apply function is in the object
    power.applyFn = power.applyFn || null;
  }
  updateActiveList();
}

/* --------- Gameplay: spawning, waves, enemies --------- */
function spawnEnemy(){
  const side = Math.floor(Math.random()*4);
  let x,y;
  if(side===0){ x = -20; y = rand(0,H); }
  else if(side===1){ x = W+20; y = rand(0,H); }
  else if(side===2){ x = rand(0,W); y = -20; }
  else { x = rand(0,W); y = H+20; }

  const t = Math.random();
  let color, speed, hp, type;
  if(t < 0.6){ color = "#f33"; speed = 70 + wave*3; hp = 1; type='normal' }
  else if(t < 0.85){ color = "#f75"; speed = 140 + wave*4; hp = 1; type='fast' }
  else { color = "#a22"; speed = 45 + wave*2; hp = 2 + Math.floor(wave/6); type='tank' }

  enemies.push({x,y,r:rand(10,18),speed,hp,color,type,vx:0,vy:0});
}

function startWave(){
  let count = 2*wave - spawnReduce;
  count = Math.max(1, count);
  for(let i=0;i<count;i++) spawnEnemy();
}

/* --------- Input --------- */
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(e.key === 'r' || e.key === 'R') resetGame();
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
  mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
});
canvas.addEventListener('mousedown', () => { mouse.down = true; tryShoot(); });
canvas.addEventListener('mouseup', () => { mouse.down = false; });

/* --------- Shooting & bullet behaviour --------- */
function tryShoot(){
  if(gameOver) return;
  const now = performance.now();
  // dynamic shot delay with low HP overcharge
  let actualShotDelay = shotDelay;
  if(fireRateScalingLowHP > 0){
    const lowRatio = clamp(1 - player.hp / player.maxHp, 0, 1); // 0..1 based on missing HP
    actualShotDelay = shotDelay / (1 + fireRateScalingLowHP * lowRatio);
  }
  if(now - lastShot < actualShotDelay) return;
  lastShot = now;

  // number of projectiles = 1 + shotgun
  const totalShots = 1 + shotgun;
  const baseAng = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  const spread = shotgun > 0 ? shotgunSpread * Math.max(1, shotgun) : 0;

  for(let s = 0; s < totalShots; s++){
    const offset = totalShots === 1 ? 0 : (s - (totalShots-1)/2) * spread;
    spawnBullet(baseAng + offset);
  }

  // Double Tap / extra-shot chance: implement as percent per stack (8% per stack)
  const doubleStacks = powerCounts['double_shot'] || 0;
  if(doubleStacks > 0){
    if(Math.random() < 0.08 * doubleStacks){
      // fire immediate extra volley at slight angular jitter
      for(let s = 0; s < totalShots; s++){
        const offset = totalShots === 1 ? 0 : (s - (totalShots-1)/2) * spread;
        spawnBullet(baseAng + offset + rand(-0.08,0.08));
      }
    }
  }
}

function spawnBullet(ang){
  const vx = Math.cos(ang) * bulletSpeed;
  const vy = Math.sin(ang) * bulletSpeed;
  bullets.push({
    x: player.x + Math.cos(ang) * (player.r + 12),
    y: player.y + Math.sin(ang) * (player.r + 12),
    vx, vy,
    r: bulletRadius,
    life: 1400,
    damage: bulletDamage,
    pierce: pierce,
    bounces: ricochet,
    explosive: explosive,
    ricochetLeft: ricochet,
    collided: false,
    homing: homing
  });
}

/* --------- Game reset --------- */
function resetGame(){
  bullets = []; enemies = []; wave = 1; betweenWave = 0; score = 0; lastShot = 0; gameOver = false;
  // reset player stats but keep applied powers (stacking remains)
  // revert to defaults then reapply stacks
  bulletSpeed = 700; bulletRadius = 4; bulletDamage = 1; pierce = 0; shotgun = 0; explosive = 0;
  ricochet = 0; homing = 0; critChance = 0; critMult = 1.5; healOnKill = 0; lifesteal = 0;
  moveSpeedBonus = 0; maxHpBonus = 0; armor = 0; regenPerSecond = 0; slowAura = 0;
  stunChance = 0; fireRateScalingLowHP = 0; spawnReduce = 0; extraScore = 0; player.shield = 0;
  player.maxHp = 100; player.hp = 100; player.speed = 240;
  shotDelay = defaultShotDelay;

  // reapply each power stacks
  for(const p of ALL_POWERS){
    const n = powerCounts[p.id] || 0;
    for(let i=0;i<n;i++){
      if(p.applyFn) p.applyFn();
    }
  }
  startWave();
  updateActiveList();
}

/* --------- Collision between enemies (soft separation) --------- */
function separateEnemies(){
  // basic pairwise separation
  for(let i=0;i<enemies.length;i++){
    for(let j=i+1;j<enemies.length;j++){
      const a = enemies[i], b = enemies[j];
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const d = Math.hypot(dx, dy) || 0.001;
      const minDist = a.r + b.r;
      if(d < minDist){
        // overlap push
        const overlap = (minDist - d) / 2;
        const nx = dx / d, ny = dy / d;
        // apply slight push - crowd push scales with powerCounts['bounce_up']
        const pushFactor = 1 + (powerCounts['bounce_up'] || 0) * 0.12;
        a.x += nx * overlap * pushFactor;
        a.y += ny * overlap * pushFactor;
        b.x -= nx * overlap * pushFactor;
        b.y -= ny * overlap * pushFactor;
      }
    }
  }
}

/* --------- Update loop --------- */
let lastTime = performance.now();
function update(dt){
  if(gameOver) return;

  // player movement
  let dx = 0, dy = 0;
  if(keys['w'] || keys['arrowup']) dy -= 1;
  if(keys['s'] || keys['arrowdown']) dy += 1;
  if(keys['a'] || keys['arrowleft']) dx -= 1;
  if(keys['d'] || keys['arrowright']) dx += 1;
  if(dx || dy){
    const len = Math.hypot(dx,dy); dx /= len; dy /= len;
    player.x += dx * player.speed * (1 + moveSpeedBonus) * dt;
    player.y += dy * player.speed * (1 + moveSpeedBonus) * dt;
    player.x = clamp(player.x, player.r, W - player.r);
    player.y = clamp(player.y, player.r, H - player.r);
  }

  // continuous shooting
  if(mouse.down) tryShoot();

  // bullets update
  for(let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    // homing behavior
    if(b.homing > 0 || homing > 0){
      // find nearest enemy
      let nearest = null, nd = 1e9;
      for(const e of enemies){
        const d = Math.hypot(e.x - b.x, e.y - b.y);
        if(d < nd){ nd = d; nearest = e; }
      }
      if(nearest && nd < 600){
        const targetAng = Math.atan2(nearest.y - b.y, nearest.x - b.x);
        // blend velocity towards target angle
        const curAng = Math.atan2(b.vy, b.vx);
        const blend = 0.06 * (1 + homing); // stronger homing stacks
        const newAng = curAng + (targetAng - curAng) * blend;
        const spd = Math.hypot(b.vx, b.vy);
        b.vx = Math.cos(newAng) * spd;
        b.vy = Math.sin(newAng) * spd;
      }
    }

    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.life -= dt * 1000;
    // bounce off walls if ricochet present
    if(b.ricochetLeft > 0){
      let bounced = false;
      if(b.x < -10 || b.x > W + 10){
        b.vx *= -1; b.ricochetLeft--; bounced = true;
      }
      if(b.y < -10 || b.y > H + 10){
        b.vy *= -1; b.ricochetLeft--; bounced = true;
      }
      if(bounced) { /* small life penalty on bounce */ b.life -= 200; }
    }
    if(b.life <= 0 || b.x < -40 || b.x > W + 40 || b.y < -40 || b.y > H + 40){
      bullets.splice(i,1);
    }
  }

  // enemies move toward player
  for(const e of enemies){
    const ang = Math.atan2(player.y - e.y, player.x - e.x);
    // apply slow aura to speed
    let speedMod = 1;
    if(slowAura > 0){
      const d = Math.hypot(e.x - player.x, e.y - player.y);
      const auraRadius = 120;
      if(d < auraRadius){
        speedMod -= slowAura; // slows by percent
      }
    }
    e.x += Math.cos(ang) * e.speed * speedMod * dt;
    e.y += Math.sin(ang) * e.speed * speedMod * dt;
  }

  // enemy separation/collision
  separateEnemies();

  // enemy-player collision
  for(let i = enemies.length - 1; i >= 0; i--){
    const e = enemies[i];
    if(dist(e, player) < e.r + player.r){
      // enemy hits player
      let rawDmg = 8 + Math.floor(wave / 3);
      rawDmg = rawDmg * (1 - armor); // damage reduced by armor
      let effective = rawDmg;
      // shield absorbs
      if(player.shield > 0){
        const takenFromShield = Math.min(player.shield, effective);
        player.shield -= takenFromShield;
        effective -= takenFromShield;
      }
      player.hp -= effective;
      // enemy dies on hitting player
      enemies.splice(i,1);
      continue;
    }
  }

  // bullet-enemy collision
  for(let i = enemies.length - 1; i >= 0; i--){
    const e = enemies[i];
    let killed = false;
    for(let j = bullets.length - 1; j >= 0; j--){
      const b = bullets[j];
      if(dist(e, b) < e.r + b.r){
        // hit
        let dmg = b.damage;
        // critical
        if(Math.random() < critChance){
          dmg *= critMult;
        }
        // lifesteal (percent of damage)
        if(lifesteal > 0){
          const healAmt = dmg * lifesteal;
          player.hp = Math.min(player.maxHp, player.hp + healAmt);
        }
        // apply to enemy
        e.hp -= dmg;
        // handle pierce: reduce pierce count and remove if none left
        if(b.pierce > 0){
          b.pierce--;
        } else {
          bullets.splice(j,1);
        }

        // stun proc
        if(stunChance > 0 && Math.random() < stunChance){
          // simple stun: push enemy slightly back and slow for a second (we'll simulate by moving it)
          e.x -= (b.vx * 0.02);
          e.y -= (b.vy * 0.02);
        }

        if(e.hp <= 0){
          // kill
          score += 10 + extraScore;
          // heal on kill fixed value
          if(healOnKill > 0){
            player.hp = Math.min(player.maxHp, player.hp + healOnKill);
          }
          // explosion handling
          if(b.explosive && explosive > 0){
            // create splash damage around e
            const splashRadius = 28 + 6 * explosive;
            for(let k = enemies.length - 1; k >= 0; k--){
              if(k === i) continue;
              const e2 = enemies[k];
              if(Math.hypot(e2.x - e.x, e2.y - e.y) <= splashRadius){
                e2.hp -= 1 + explosive;
                if(e2.hp <= 0){
                  score += 10 + extraScore;
                  enemies.splice(k,1);
                  if(k < i) i--; // adjust main index if needed
                }
              }
            }
          }
          enemies.splice(i,1);
          killed = true;
        }
        break;
      }
    }
    if(killed) continue;
  }

  // wave logic
  if(enemies.length === 0 && betweenWave <= 0){
    betweenWave = 3;
    // show power choices overlay
    showChoiceOverlay();
  }
  if(betweenWave > 0){
    betweenWave -= dt;
  }

  // regen
  if(regenPerSecond > 0){
    player.hp = Math.min(player.maxHp, player.hp + regenPerSecond * dt);
  }

  if(player.hp <= 0){
    player.hp = 0; gameOver = true;
    overlay.hidden = false;
    // show game over panel inside overlay
    showGameOver();
  }

  // update HUD
  elWave.textContent = wave;
  elEnemies.textContent = enemies.length;
  elHp.textContent = Math.floor(player.hp);
  elScore.textContent = Math.floor(score);
}

/* --------- UI: Power choice overlay --------- */
function pickRandomThree(){
  // sample 3 distinct items from ALL_POWERS uniformly
  const out = [];
  const pool = ALL_POWERS.slice();
  while(out.length < 3 && pool.length){
    const idx = Math.floor(Math.random()*pool.length);
    out.push(pool.splice(idx,1)[0]);
  }
  return out;
}

function showChoiceOverlay(){
  // pause game loop by setting betweenWave large? We'll show overlay and stop spawning until selection
  overlay.hidden = false;
  choicesNode.innerHTML = '';
  const picks = pickRandomThree();
  for(const p of picks){
    const card = document.createElement('div');
    card.className = 'card';
    const h = document.createElement('h3'); h.textContent = p.name;
    const d = document.createElement('p'); d.textContent = p.desc;
    const info = document.createElement('div'); info.className = 'small';
    const times = powerCounts[p.id] || 0;
    info.textContent = `Owned: ${times}`;
    card.appendChild(h); card.appendChild(d); card.appendChild(info);
    card.onclick = () => {
      // grant and close
      powerCounts[p.id] = (powerCounts[p.id] || 0) + 1;
      if(p.applyFn) p.applyFn();
      overlay.hidden = true;
      choicesNode.innerHTML = '';
      // start next wave after short delay (0.2s)
      setTimeout(()=>{ wave++; startWave(); }, 180);
      updateActiveList();
    };
    choicesNode.appendChild(card);
  }
}

function showGameOver(){
  choicesNode.innerHTML = '';
  const panel = document.getElementById('pickPanel');
  panel.innerHTML = '<div class="title">YOU DIED</div><div style="text-align:center;margin:12px 0">Score: ' + Math.floor(score) + '</div><div style="text-align:center"><button class="small" onclick="location.reload()">Restart</button></div>';
}

/* --------- Active power list UI --------- */
function updateActiveList(){
  activeListNode.innerHTML = '';
  for(const p of ALL_POWERS){
    const n = powerCounts[p.id] || 0;
    if(n > 0){
      const div = document.createElement('div');
      div.className = 'powerItem';
      div.textContent = `${p.name} Ã—${n}`;
      activeListNode.appendChild(div);
    }
  }
}

/* --------- Draw --------- */
function draw(){
  // clear
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);

  // draw bullets
  ctx.fillStyle = '#ffd';
  for(const b of bullets){
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fill();
  }

  // draw enemies
  for(const e of enemies){
    ctx.beginPath();
    ctx.arc(e.x,e.y,e.r,0,Math.PI*2);
    ctx.fillStyle = e.color;
    ctx.fill();
    // subtle outline
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.stroke();
  }

  // player polished look (no glow)
  const grad = ctx.createLinearGradient(player.x-player.r, player.y-player.r, player.x+player.r, player.y+player.r);
  grad.addColorStop(0, '#7dc8ff');
  grad.addColorStop(1, '#2767ff');
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = '#0d204f';
  ctx.stroke();

  // pointer
  const a = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  ctx.beginPath();
  ctx.moveTo(player.x, player.y);
  ctx.lineTo(player.x + Math.cos(a) * (player.r + 10), player.y + Math.sin(a) * (player.r + 10));
  ctx.strokeStyle = '#cce3ff';
  ctx.lineWidth = 2;
  ctx.stroke();

  // between wave message
  if(enemies.length === 0 && !gameOver && betweenWave > 0){
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(W/2 - 180, H/2 - 52, 360, 104);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '20px Inter, Arial';
    ctx.fillText('Choosing reward...', W/2, H/2 - 4);
  }

  // if gameOver overlay handled separately
}

/* --------- Main loop & resize --------- */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
loop(last);

function resize(){
  W = innerWidth; H = innerHeight;
  canvas.width = W; canvas.height = H;
  player.x = clamp(player.x, player.r, W - player.r);
  player.y = clamp(player.y, player.r, H - player.r);
}
window.addEventListener('resize', resize);

/* --------- initialize start wave & UI --------- */
startWave();
updateActiveList();

/* --------- Power descriptions (for quick reference in overlay code) --------- */
/* The ALL_POWERS array already contains names & descriptions used above. */

</script>
</body>
</html>
