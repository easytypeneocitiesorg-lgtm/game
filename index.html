<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wave Shooter — Single File</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#eee;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  #gameWrap{display:flex;flex-direction:column;align-items:center;gap:10px;padding:12px;}
  canvas{background:#0b0b0b;border:2px solid #222;border-radius:8px;touch-action:none;}
  .hud{display:flex;gap:12px;align-items:center;font-weight:600;}
  .small{font-size:14px;opacity:.85}
  .center{display:flex;flex-direction:column;align-items:center;gap:6px}
  button{padding:8px 12px;border-radius:8px;border:0;background:#1f6feb;color:white;cursor:pointer}
  .muted{opacity:.7;font-size:13px}
  .instructions{font-size:13px}
</style>
</head>
<body>
<div id="gameWrap" class="center">
  <h2 style="margin:0">Wave Shooter</h2>
  <div class="hud">
    <div>Wave: <span id="wave">1</span></div>
    <div>Enemies: <span id="enemiesAlive">0</span></div>
    <div>Score: <span id="score">0</span></div>
    <div>HP: <span id="hp">100</span></div>
  </div>
  <canvas id="c" width="900" height="600"></canvas>
  <div class="instructions muted">Move: WASD or Arrow keys • Aim & Shoot: Mouse (click) • Restart: R</div>
  <div style="height:6px"></div>
  <div class="muted small">Waves start at 2 enemies and add 2 each wave. 3s delay between waves.</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  const W = canvas.width, H = canvas.height;

  // HUD elements
  const elWave = document.getElementById('wave');
  const elEnemies = document.getElementById('enemiesAlive');
  const elScore = document.getElementById('score');
  const elHp = document.getElementById('hp');

  // Game state
  let keys = {};
  let mouse = { x: W/2, y: H/2, down:false };
  let bullets = [];
  let enemies = [];
  let particles = [];
  let score = 0;
  let player = { x: W/2, y: H/2, r: 14, speed: 240, hp: 100 };
  let lastShot = 0;
  const shotCooldown = 150; // ms
  let lastTime = performance.now();

  // Waves: start at wave=1 which has 2 enemies (2*wave)
  let wave = 1;
  let spawning = false;
  let betweenWaveTimer = 0; // ms remaining before next wave
  const BETWEEN_WAVE_MS = 3000;

  // Helpers
  function rand(min, max){ return Math.random()*(max-min)+min; }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  // Spawn enemies at edges
  function spawnEnemy(){
    const side = Math.floor(Math.random()*4);
    let x, y;
    if(side===0){ x = -20; y = rand(0,H); }
    if(side===1){ x = W+20; y = rand(0,H); }
    if(side===2){ x = rand(0,W); y = -20; }
    if(side===3){ x = rand(0,W); y = H+20; }
    const spd = rand(40,110) + wave*3;
    enemies.push({
      x, y,
      r: rand(10,18),
      speed: spd,
      hp: 1 + Math.floor(wave/4),
      color: 'rgba(255,60,60,0.95)'
    });
  }

  function startWave(){
    spawning = true;
    const count = 2 * wave; // start 2, +2 each wave
    for(let i=0;i<count;i++) spawnEnemy();
    spawning = false;
  }

  // initial wave
  startWave();

  // Input
  window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key==='r' || e.key==='R') resetGame(); });
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });
  canvas.addEventListener('mousedown', e => { mouse.down = true; shootTry(); });
  canvas.addEventListener('mouseup', e => { mouse.down = false; });

  // Touch support (simple)
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.touches[0]; const rect = canvas.getBoundingClientRect();
    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);
    mouse.down = true; shootTry();
  }, {passive:false});
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const t = e.touches[0]; const rect = canvas.getBoundingClientRect();
    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);
  }, {passive:false});
  canvas.addEventListener('touchend', e => { mouse.down = false; });

  // Shooting
  function shootTry() {
    const now = performance.now();
    if(now - lastShot < shotCooldown) return;
    lastShot = now;
    // Bullet direction from player to mouse
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    const spd = 700;
    bullets.push({
      x: player.x + Math.cos(ang)*(player.r+8),
      y: player.y + Math.sin(ang)*(player.r+8),
      vx: Math.cos(ang)*spd,
      vy: Math.sin(ang)*spd,
      r: 4,
      life: 1400
    });
  }

  // Game reset
  function resetGame(){
    bullets = []; enemies=[]; particles=[]; score=0; player.hp=100; wave=1; betweenWaveTimer=0; startWave();
  }

  // Particle for tiny effects
  function spawnParticles(x,y,col,count=10){
    for(let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const s = rand(60,240);
      particles.push({
        x, y,
        vx: Math.cos(a)*s, vy: Math.sin(a)*s,
        life: rand(400,900),
        r: rand(1.5,3.5),
        color: col
      });
    }
  }

  // Main loop
  function update(dt){
    // Player move (WASD or arrows)
    let dx = 0, dy = 0;
    if(keys['w'] || keys['arrowup']) dy -= 1;
    if(keys['s'] || keys['arrowdown']) dy += 1;
    if(keys['a'] || keys['arrowleft']) dx -= 1;
    if(keys['d'] || keys['arrowright']) dx += 1;
    if(dx!==0 || dy!==0){
      const len = Math.hypot(dx,dy);
      dx/=len; dy/=len;
      player.x += dx * player.speed * dt;
      player.y += dy * player.speed * dt;
      // clamp
      player.x = Math.max(player.r, Math.min(W-player.r, player.x));
      player.y = Math.max(player.r, Math.min(H-player.r, player.y));
    }

    // Continuous shooting if mouse is down
    if(mouse.down) shootTry();

    // Update bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      b.life -= dt*1000;
      if(b.life<=0 || b.x<-20 || b.x>W+20 || b.y<-20 || b.y>H+20) bullets.splice(i,1);
    }

    // Update enemies — simple homing towards player
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      const ang = Math.atan2(player.y - e.y, player.x - e.x);
      const vx = Math.cos(ang)*e.speed;
      const vy = Math.sin(ang)*e.speed;
      e.x += vx*dt;
      e.y += vy*dt;

      // collision with player
      if(dist(e, player) < e.r + player.r){
        // deal damage and remove enemy
        player.hp -= 8 + Math.floor(wave/3);
        spawnParticles(e.x,e.y,'rgba(255,120,100,0.9)', 8);
        enemies.splice(i,1);
      }
    }

    // Bullets hit enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      for(let j=bullets.length-1;j>=0;j--){
        const b = bullets[j];
        if(Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.r){
          // hit
          e.hp--;
          bullets.splice(j,1);
          if(e.hp <= 0){
            // enemy dies
            score += 10;
            spawnParticles(e.x,e.y,'rgba(255,200,120,0.95)', 12);
            enemies.splice(i,1);
          }
          break;
        }
      }
    }

    // Update particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt*1000;
      if(p.life <= 0) particles.splice(i,1);
    }

    // Wave logic: if no enemies left, start 3s delay then next wave
    if(enemies.length === 0 && betweenWaveTimer <= 0){
      betweenWaveTimer = BETWEEN_WAVE_MS;
    }
    if(betweenWaveTimer > 0){
      betweenWaveTimer -= dt*1000;
      if(betweenWaveTimer <= 0){
        wave++;
        startWave();
      }
    }

    // Simple death: if player HP <= 0 -> game over, show message and allow R to restart
    if(player.hp <= 0){
      player.hp = 0;
      // freeze the game but keep UI
      // stop inputs by clearing arrays and setting a "dead" state
      bullets = [];
      // create a loss screen via overlay drawing in render
    }

    // Update HUD
    elWave.textContent = wave;
    elEnemies.textContent = enemies.length;
    elScore.textContent = score;
    elHp.textContent = Math.max(0, Math.floor(player.hp));
  }

  function render(){
    // background
    ctx.fillStyle = '#0b0b0b';
    ctx.fillRect(0,0,W,H);

    // draw particles behind
    for(const p of particles){
      ctx.beginPath();
      ctx.globalAlpha = Math.max(0, p.life/900);
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = p.color;
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // draw bullets
    for(const b of bullets){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle = '#ffd'; ctx.fill();
    }

    // draw enemies (red circles)
    for(const e of enemies){
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fillStyle = e.color;
      ctx.fill();
      // small health indicator ring
      if(e.hp > 1){
        const ratio = Math.min(1,e.hp/ (1 + Math.floor(wave/4)));
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r+4, -Math.PI/2, -Math.PI/2 + Math.PI*2*ratio);
        ctx.stroke();
      }
    }

    // draw player (blueish circle with direction marker)
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.fillStyle = '#5aa6ff';
    ctx.fill();
    // direction pointer
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    ctx.beginPath();
    ctx.moveTo(player.x, player.y);
    ctx.lineTo(player.x + Math.cos(ang)*(player.r+12), player.y + Math.sin(ang)*(player.r+12));
    ctx.strokeStyle = '#cfefff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // if between waves, show countdown
    if(enemies.length===0 && player.hp>0 && betweenWaveTimer>0){
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fillRect(W/2 - 150, H/2 - 60, 300, 120);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = '24px system-ui, sans-serif';
      const secs = Math.ceil(betweenWaveTimer/1000);
      ctx.fillText(`Wave ${wave+1} in ${secs}`, W/2, H/2);
    }

    // if player dead show overlay
    if(player.hp <= 0){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#ff8080';
      ctx.textAlign = 'center';
      ctx.font = '40px system-ui, sans-serif';
      ctx.fillText('YOU DIED', W/2, H/2 - 10);
      ctx.font = '18px system-ui, sans-serif';
      ctx.fillStyle = '#fff';
      ctx.fillText(`Score: ${score} — Press R to restart`, W/2, H/2 + 26);
    }
  }

  function loop(now){
    const dt = Math.min(0.05, (now - lastTime) / 1000); // clamp dt
    lastTime = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // make the game responsive-ish: scale canvas to fit while keeping resolution
  function fitCanvas(){
    const maxW = Math.min(window.innerWidth - 40, 1000);
    const maxH = Math.min(window.innerHeight - 160, 700);
    const scale = Math.min(maxW / W, maxH / H, 1);
    canvas.style.width = Math.round(W * scale) + 'px';
    canvas.style.height = Math.round(H * scale) + 'px';
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

})();
</script>
</body>
</html>
